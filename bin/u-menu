#!/usr/bin/env ruby

require_relative '../lib/u-menu'

require 'tty-prompt'

config = Micro::Menu.configurations.load
colors = Micro::Menu.colors
prompt = TTY::Prompt.new(prefix: colors.magenta("\uea85 \u00b5menu "), interrupt: :signal)

icons = Micro::Menu.icons.all
messages = Micro::Menu.messages

trap('INT') do
  thanks = messages.thanks

  puts "\n\n#{thanks.sample}"
  exit(0)
end

action = nil
title, options = config.values_at(:title, :options)

options << {
  name: '{{settings}} Edit Settings',
  type: 'edit',
  value: 'settings',
  execute: config[:_path]
}
options = options.sort { |a, b| a[:name] <=> b[:name] }

options.each do |option|
  if option[:name].match(/\{\{(?<icon_name>.*)\}\}/)
    icon_name = Regexp.last_match('icon_name')
    option[:name].sub!("{{#{icon_name}}}", icons[icon_name])
  else
    option[:name] = "#{icons['terminal']} #{option[:name]}" if option[:type] == 'command'
    option[:name] = "#{icons['link']} #{option[:name]}" if option[:type] == 'link'
  end
end

loop do
  choice = prompt.select(title, options, filter: true)
  action = config[:options].find { |item| item[:value] == choice }

  case action[:type]
  when 'command'
    system action[:execute]
  when 'link'
    puts "#{colors.bold('Sure... opening link')} '#{colors.cyan(action[:execute])}'"
    system "open #{action[:execute]} &"
  when 'edit'
    puts "#{colors.bold('Sure... opening file')} '#{colors.cyan(action[:execute])}'"
    system "#{config[:settings][:editor]} #{action[:execute]}"
  end

  exit(0)
rescue StandardError => e
  puts "#{colors.red('[error]')} #{e}"
  exit(1)
end
